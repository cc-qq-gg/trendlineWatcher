<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title></title>
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 10px;
        background-color: #f5f5f5;
        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        -webkit-text-size-adjust: 100%;
        -webkit-tap-highlight-color: transparent;
      }
      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 0 10px;
      }
      .header {
        text-align: center;
        margin-bottom: 15px;
      }
      .header h1 {
        font-size: 24px;
        margin: 10px 0;
      }
      .main-content {
        display: flex;
        gap: 20px;
        flex-direction: row;
      }
      .chart-container {
        flex: 1;
        background: white;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        min-width: 0; /* é˜²æ­¢flexå­é¡¹æº¢å‡º */
      }
      #chart {
        width: 100%;
      }
      .sidebar {
        width: 380px;
        background: white;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        flex-shrink: 0;
        overflow-y: auto;
        max-height: calc(100vh - 120px);
      }
      .controls {
        margin-bottom: 15px;
      }
      .controls-row {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }
      .controls select,
      .controls button {
        padding: 12px;
        border: 1px solid #ddd;
        border-radius: 6px;
        font-size: 14px;
        min-height: 44px; /* ç§»åŠ¨ç«¯æ¨èçš„è§¦æ‘¸ç›®æ ‡æœ€å°å°ºå¯¸ */
        box-sizing: border-box;
      }
      .controls select {
        flex: 1;
        min-width: 150px;
      }
      .controls button {
        background-color: #4caf50;
        color: white;
        cursor: pointer;
        transition: background-color 0.2s;
        min-width: 100px;
        font-weight: 500;
      }
      .controls button:hover {
        background-color: #45a049;
      }
      .controls button:active {
        background-color: #3d8b40;
        transform: translateY(1px);
      }
      .controls button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
        transform: none;
      }
      .controls button.secondary {
        background-color: #2196f3;
      }
      .controls button.secondary:hover {
        background-color: #1976d2;
      }
      .controls button.danger {
        background-color: #f44336;
      }
      .controls button.danger:hover {
        background-color: #d32f2f;
      }
      .trendlines-list {
        max-height: 600px;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch; /* ç§»åŠ¨ç«¯æ»šåŠ¨ä¼˜åŒ– */
      }
      .trendline-item {
        border: 1px solid #ddd;
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 12px;
        background-color: #f9f9f9;
        transition: box-shadow 0.2s;
      }
      .trendline-item:hover {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      .trendline-item h4 {
        margin: 0 0 8px 0;
        color: #333;
        font-size: 14px;
        word-break: break-all;
      }
      .trendline-item p {
        margin: 5px 0;
        font-size: 13px;
        color: #666;
        line-height: 1.4;
      }
      .trendline-item .actions {
        margin-top: 12px;
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }
      .trendline-item button {
        padding: 8px 12px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        min-height: 36px;
        transition: transform 0.1s, opacity 0.2s;
        font-weight: 500;
      }
      .trendline-item button:active {
        transform: scale(0.95);
      }
      .btn-delete {
        background-color: #f44336;
        color: white;
      }
      .btn-delete:hover {
        background-color: #d32f2f;
      }
      .btn-toggle {
        background-color: #2196f3;
        color: white;
      }
      .btn-toggle:hover {
        background-color: #1976d2;
      }
      .btn-edit {
        background-color: #ff9800;
        color: white;
      }
      .btn-edit:hover {
        background-color: #f57c00;
      }
      .btn-check {
        background-color: #9c27b0;
        color: white;
      }
      .btn-check:hover {
        background-color: #7b1fa2;
      }
      .btn-chart-edit {
        background-color: #607d8b;
        color: white;
        flex: 1;
        min-width: 80px;
      }
      .btn-chart-edit:hover {
        background-color: #455a64;
      }
      .status {
        padding: 10px;
        margin-top: 20px;
        border-radius: 4px;
        text-align: center;
      }
      .status.success {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }
      .status.error {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }
      #dataInfo {
        font-size: 12px;
        color: #666;
        background-color: #f8f9fa;
        padding: 4px 8px;
        border-radius: 4px;
        border: 1px solid #dee2e6;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 300px;
      }
      .demo-info {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px;
        border-radius: 8px;
        margin-top: 20px;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
      }
      .demo-info h4 {
        margin: 0 0 10px 0;
        font-size: 16px;
        border-bottom: 2px solid rgba(255, 255, 255, 0.3);
        padding-bottom: 5px;
      }
      .demo-features {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
        margin-top: 10px;
      }
      .demo-feature {
        background: rgba(255, 255, 255, 0.1);
        padding: 8px;
        border-radius: 5px;
        font-size: 12px;
      }
      .coordinate-demo {
        display: none;
        background: rgba(255, 255, 255, 0.15);
        border-left: 4px solid #ffd700;
        padding: 10px;
        margin-top: 10px;
        border-radius: 0 5px 5px 0;
      }

      /* Loadingé®ç½©æ ·å¼ */
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.2);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        backdrop-filter: blur(2px);
      }

      .spinner {
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* å¹³æ¿é€‚é… (768px - 1024px) */
      @media screen and (max-width: 1024px) {
        .container {
          padding: 0 15px;
        }
        .sidebar {
          width: 320px;
        }
        #chart {
        }
        .trendline-item .actions {
          gap: 4px;
        }
        .trendline-item button {
          padding: 6px 8px;
          font-size: 11px;
          min-height: 32px;
        }
      }

      /* ç§»åŠ¨ç«¯é€‚é… (å°äº768px) */
      @media screen and (max-width: 768px) {
        body {
          padding: 5px;
        }
        .container {
          padding: 0 15px;
        }
        .header {
          margin-bottom: 10px;
        }
        .header h1 {
          font-size: 20px;
        }

        /* æ”¹å˜å¸ƒå±€ä¸ºå‚ç›´æ’åˆ— */
        .main-content {
          flex-direction: column;
          gap: 15px;
        }

        .chart-container {
          padding: 10px;
        }
        #chart {
        }

        .sidebar {
          box-sizing: border-box;
          width: 100%;
          max-height: 50vh;
          padding: 10px;
        }

        .controls {
          margin-bottom: 10px;
        }
        .controls-row {
          flex-direction: column;
          gap: 8px;
        }
        .controls select,
        .controls button {
          min-height: 44px;
          font-size: 16px; /* é˜²æ­¢iOSç¼©æ”¾ */
        }

        .trendlines-list {
          max-height: 40vh;
        }
        .trendline-item {
          padding: 8px;
          margin-bottom: 8px;
        }
        .trendline-item h4 {
          font-size: 13px;
        }
        .trendline-item p {
          font-size: 12px;
        }
        .trendline-item .actions {
          gap: 3px;
          margin-top: 8px;
        }
        .trendline-item button {
          padding: 6px 8px;
          font-size: 11px;
          min-height: 32px;
          flex: 1;
          min-width: 60px;
        }
      }

      /* å°å±æ‰‹æœºé€‚é… (å°äº480px) */
      @media screen and (max-width: 480px) {
        .header h1 {
          font-size: 18px;
        }
        .chart-container {
          padding: 8px;
        }
        #chart {
        }
        .sidebar {
          padding: 8px;
        }
        .controls select,
        .controls button {
          font-size: 14px;
          padding: 10px;
        }
        .trendline-item button {
          font-size: 10px;
          padding: 5px 6px;
          min-height: 28px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Loadingé®ç½© -->
    <div id="loadingOverlay" class="loading-overlay">
      <svg class="spinner" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 12a9 9 0 1 1-6.219-8.56" stroke="#4caf50"/>
      </svg>
    </div>

    <div class="container">
      <div class="main-content">
        <div class="chart-container">
          <div class="controls">
            <div class="controls-row">
              <select id="symbolSelect">
                {% for symbol in symbols %}
                <option value="{{ symbol }}">{{ symbol }}</option>
               {% endfor %}
              </select>
            </div>
            <div class="controls-row">
              <button id="refreshBtn">åˆ·æ–°æ•°æ®</button>
              <button id="drawTrendlineBtn">ç»˜åˆ¶è¶‹åŠ¿çº¿</button>
              <button
                id="clearSelectionBtn"
                class="secondary"
                style="display: none"
              >
                å–æ¶ˆé€‰æ‹©
              </button>
            </div>
            <div>
              <span id="dataInfo" style="color: #666; font-size: 12px"></span>
            </div>
          </div>
          <div id="chart"></div>
        </div>

        <div class="sidebar">
          <div id="status" class="status" style="display: none"></div>
          <div id="trendlinesList" class="trendlines-list">
            <p>åŠ è½½ä¸­...</p>
          </div>
        </div>
      </div>
    </div>

    <script>
      let chart
      let candlestickSeries
      let trendlineSeries = []
      let selectedPoints = []
      let isDrawingMode = false
      let isEditMode = false
      let editingTrendlineId = null
      let editingOriginalData = null
      let currentSymbol = 'SOL-USDT-SWAP'
      // ä¸œå…«åŒº
      const timeZonetimes = 3600 * 8

      // åˆå§‹åŒ–å›¾è¡¨
      function initChart() {
        try {
          const chartContainer = document.getElementById('chart')
          chart = LightweightCharts.createChart(chartContainer, {
            width: chartContainer.clientWidth,
            height: 600,
            layout: {
              backgroundColor: '#ffffff',
              textColor: '#333',
            },
            grid: {
              vertLines: {
                color: '#e0e0e0',
              },
              horzLines: {
                color: '#e0e0e0',
              },
            },
            crosshair: {
              mode: LightweightCharts.CrosshairMode.Normal,
            },
            rightPriceScale: {
              borderColor: '#cccccc',
            },
            timeScale: {
              borderColor: '#cccccc',
              timeVisible: true,
              secondsVisible: false,
            },
          })

          candlestickSeries = chart.addCandlestickSeries({
            upColor: '#26a69a',
            downColor: '#ef5350',
            borderVisible: false,
            wickUpColor: '#26a69a',
            wickDownColor: '#ef5350',
          })

          // åå­—çº¿ç§»åŠ¨äº‹ä»¶å¤„ç†ï¼ˆç”¨äºè·å–ä»·æ ¼æ•°æ®ï¼‰
          chart.subscribeCrosshairMove(handleCrosshairMove)

          // ç‚¹å‡»äº‹ä»¶å¤„ç†
          chart.subscribeClick(handleChartClick)

          console.log('å›¾è¡¨åˆå§‹åŒ–æˆåŠŸ')
        } catch (error) {
          console.error('å›¾è¡¨åˆå§‹åŒ–å¤±è´¥:', error)
          showStatus('å›¾è¡¨åˆå§‹åŒ–å¤±è´¥: ' + error.message, 'error')
        }
      }

      // åˆ›å»ºè¶‹åŠ¿çº¿
      function createTrendline() {
        if (selectedPoints.length !== 2) return

        const startPoint = selectedPoints[0]
        const endPoint = selectedPoints[1]

        // è®¡ç®—è¶‹åŠ¿çº¿æ–¹å‘ï¼ˆåŸºäºä»·æ ¼å˜åŒ–ï¼‰
        const direction = endPoint.price > startPoint.price ? 1 : -1
        const directionText = direction === 1 ? 'åšå¤š' : 'åšç©º'

        // ç”Ÿæˆè¶‹åŠ¿çº¿åç§°
        const trendlineName = `${directionText}_è¶‹åŠ¿çº¿_${new Date().toLocaleTimeString()}`

        const trendlineData = {
          name: trendlineName,
          symbol: currentSymbol,
          startPoint: {
            time: convertTimeToString(startPoint.time),
            price: startPoint.price.toFixed(2),
            priceInfo: startPoint.priceInfo
              ? startPoint.priceInfo.description
              : null,
            candleData: startPoint.priceInfo
              ? {
                  open: startPoint.priceInfo.open,
                  high: startPoint.priceInfo.high,
                  low: startPoint.priceInfo.low,
                  close: startPoint.priceInfo.close,
                }
              : null,
          },
          endPoint: {
            time: convertTimeToString(endPoint.time),
            price: endPoint.price.toFixed(2),
            priceInfo: endPoint.priceInfo
              ? endPoint.priceInfo.description
              : null,
            candleData: endPoint.priceInfo
              ? {
                  open: endPoint.priceInfo.open,
                  high: endPoint.priceInfo.high,
                  low: endPoint.priceInfo.low,
                  close: endPoint.priceInfo.close,
                }
              : null,
          },
          direction: direction,
        }

        console.log('åˆ›å»ºè¶‹åŠ¿çº¿æ•°æ®:', trendlineData)

        showLoading()

        fetch('/api/trendlines', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(trendlineData),
        })
          .then((response) => response.json())
          .then((data) => {
            hideLoading()
            if (data.success) {
              showStatus('è¶‹åŠ¿çº¿åˆ›å»ºæˆåŠŸ', 'success')
              loadTrendlines()
              drawExistingTrendlines() // ç›´æ¥ç»˜åˆ¶æ–°è¶‹åŠ¿çº¿
            } else {
              showStatus(
                'åˆ›å»ºè¶‹åŠ¿çº¿å¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'),
                'error'
              )
            }
            clearSelection()
          })
          .catch((error) => {
            hideLoading()
            console.error('åˆ›å»ºè¶‹åŠ¿çº¿å¤±è´¥:', error)
            showStatus('åˆ›å»ºè¶‹åŠ¿çº¿å¤±è´¥: ' + error.message, 'error')
            clearSelection()
          })
      }

      // è½¬æ¢æ—¶é—´æ ¼å¼
      function convertTimeToString(time) {
        const date = new Date(time * 1000)
        const year = date.getFullYear()
        const month = String(date.getMonth() + 1).padStart(2, '0')
        const day = String(date.getDate()).padStart(2, '0')
        const hour = String(date.getHours()).padStart(2, '0')
        const minute = String(date.getMinutes()).padStart(2, '0')
        const second = String(date.getSeconds()).padStart(2, '0')
        return `${year}-${month}-${day} ${hour}:${minute}:${second}`
      }

      let validData = []

      // æ˜¾ç¤º/éšè—Loadingé®ç½©
      function showLoading() {
        const overlay = document.getElementById('loadingOverlay')
        overlay.style.display = 'flex'
      }

      function hideLoading() {
        const overlay = document.getElementById('loadingOverlay')
        overlay.style.display = 'none'
      }

      // åŠ è½½Kçº¿æ•°æ®
      function loadKlineData() {
        showLoading()

        return fetch(`/api/kline/${currentSymbol}?limit=2000`)
          .then((response) => {
            if (!response.ok) {
              throw new Error('Network response was not ok')
            }
            return response.json()
          })
          .then((data) => {
            hideLoading()

            console.log('æ”¶åˆ°æ•°æ®:', data)
            console.log('æ•°æ®ç±»å‹:', typeof data)
            console.log('æ•°æ®é•¿åº¦:', data.length)

            if (data.error) {
              showStatus('åŠ è½½Kçº¿æ•°æ®å¤±è´¥: ' + data.error, 'error')
              return
            }

            if (!Array.isArray(data)) {
              showStatus('æ•°æ®æ ¼å¼é”™è¯¯ï¼šä¸æ˜¯æ•°ç»„', 'error')
              console.error('æ•°æ®ä¸æ˜¯æ•°ç»„:', data)
              return
            }

            if (data.length === 0) {
              showStatus('æš‚æ— æ•°æ®', 'error')
              return
            }
            data?.forEach((candle) => {
              candle.time = candle.time + timeZonetimes
            })
            data?.sort((a, b) => a.time - b.time)

            // éªŒè¯æ‰€æœ‰æ•°æ®ï¼Œç¡®ä¿æ²¡æœ‰nullå€¼
            validData = data.filter((candle) => {
              return (
                candle &&
                typeof candle === 'object' &&
                candle.time !== null &&
                candle.time !== undefined &&
                candle.open !== null &&
                candle.open !== undefined &&
                candle.high !== null &&
                candle.high !== undefined &&
                candle.low !== null &&
                candle.low !== undefined &&
                candle.close !== null &&
                candle.close !== undefined &&
                !isNaN(candle.time) &&
                !isNaN(candle.open) &&
                !isNaN(candle.high) &&
                !isNaN(candle.low) &&
                !isNaN(candle.close)
              )
            })

            if (validData.length === 0) {
              showStatus('æ²¡æœ‰æœ‰æ•ˆçš„Kçº¿æ•°æ®', 'error')
              console.error('æ‰€æœ‰æ•°æ®éƒ½æ— æ•ˆ')
              return
            }

            if (validData.length < data.length) {
              console.warn(
                `è¿‡æ»¤æ‰äº† ${data.length - validData.length} æ¡æ— æ•ˆæ•°æ®`
              )
            }

            console.log('æœ‰æ•ˆæ•°æ®æ¡æ•°:', validData.length)
            console.log('ç¬¬ä¸€æ¡æœ‰æ•ˆæ•°æ®:', validData[0])

            // å°è¯•è®¾ç½®æ•°æ®ï¼Œå¦‚æœå¤±è´¥åˆ™æ˜¾ç¤ºé”™è¯¯
            try {
              candlestickSeries.setData(validData)
              chart.timeScale().fitContent()
              drawExistingTrendlines()
              showStatus(`æ•°æ®å·²æ›´æ–° (${validData.length}æ¡)`, 'success')
              updateDataInfo(validData)
            } catch (chartError) {
              console.error('å›¾è¡¨è®¾ç½®æ•°æ®å¤±è´¥:', chartError)
              console.error('é”™è¯¯è¯¦æƒ…:', chartError.message)
              console.error('é”™è¯¯å †æ ˆ:', chartError.stack)

              // å°è¯•è·å–æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
              if (chartError.message.includes('null')) {
                showStatus('æ•°æ®åŒ…å«nullå€¼ï¼Œè¯·æ£€æŸ¥æ•°æ®æ ¼å¼', 'error')
              } else {
                showStatus('å›¾è¡¨æ˜¾ç¤ºå¤±è´¥ï¼š' + chartError.message, 'error')
              }
            }
          })
          .catch((error) => {
            hideLoading()
            console.error('åŠ è½½Kçº¿æ•°æ®å¤±è´¥:', error)
            showStatus('åŠ è½½Kçº¿æ•°æ®å¤±è´¥: ' + error.message, 'error')
          })
      }

      // åŠ è½½è¶‹åŠ¿çº¿åˆ—è¡¨
      function loadTrendlines() {
        showLoading()

        return fetch(`/api/trendlines?symbol=${currentSymbol}`)
          .then((response) => response.json())
          .then((data) => {
            hideLoading()
            console.log('è¶‹åŠ¿çº¿åˆ—è¡¨APIå“åº”:', data)
            if (data && data.success && data.data) {
              renderTrendlinesList(data.data)
            } else {
              console.error('è¶‹åŠ¿çº¿æ•°æ®æ ¼å¼é”™è¯¯:', data)
              document.getElementById('trendlinesList').innerHTML =
                '<p style="color: red;">è¶‹åŠ¿çº¿æ•°æ®æ ¼å¼é”™è¯¯</p>'
            }
          })
          .catch((error) => {
            hideLoading()
            console.error('åŠ è½½è¶‹åŠ¿çº¿å¤±è´¥:', error)
            document.getElementById('trendlinesList').innerHTML =
              '<p style="color: red;">åŠ è½½è¶‹åŠ¿çº¿å¤±è´¥</p>'
          })
      }

      // æ¸²æŸ“è¶‹åŠ¿çº¿åˆ—è¡¨
      function renderTrendlinesList(trendlines) {
        const container = document.getElementById('trendlinesList')

        console.log('æ‰€æœ‰è¶‹åŠ¿çº¿:', trendlines)

        if (trendlines.length === 0) {
          container.innerHTML = '<p>æš‚æ— è¶‹åŠ¿çº¿</p>'
          return
        }

        container.innerHTML = trendlines
          .map(
            (tl) => `
                <div class="trendline-item" data-id="${tl.id}">
                    <h4>${tl.symbol}</h4>
                    <p><strong>æ–¹å‘ï¼š</strong>${
                      tl.direction === 1 ? 'åšå¤š ğŸ“ˆ' : 'åšç©º ğŸ“‰'
                    }</p>
                    <p><strong>èµ·ç‚¹ï¼š</strong>${
                      tl.startPoint.time
                    } ä»·æ ¼ï¼š$${parseFloat(tl.startPoint.price).toFixed(2)}</p>
                    ${
                      tl.startPoint.priceInfo
                        ? `<p style="font-size: 11px; color: #666; margin-left: 10px;">${tl.startPoint.priceInfo}</p>`
                        : ''
                    }
                    <p><strong>ç»ˆç‚¹ï¼š</strong>${
                      tl.endPoint.time
                    } ä»·æ ¼ï¼š$${parseFloat(tl.endPoint.price).toFixed(2)}</p>
                    ${
                      tl.endPoint.priceInfo
                        ? `<p style="font-size: 11px; color: #666; margin-left: 10px;">${tl.endPoint.priceInfo}</p>`
                        : ''
                    }
                    <p><strong>åˆ›å»ºæ—¶é—´ï¼š</strong>${new Date(
                      tl.createdAt
                    ).toLocaleString()}<strong>æ›´æ–°æ—¶é—´ï¼š</strong>${new Date(
                      tl.updatedAt
                    ).toLocaleString()}</p>
                    <p><strong>çŠ¶æ€ï¼š</strong>${
                      tl.enabled ? 'å¯ç”¨ âœ…' : 'ç¦ç”¨ âŒ'
                    }</p>
                    <div class="actions">
                        <button class="btn-chart-edit" onclick="startEditTrendlineFromChart('${
                          tl.id
                        }')">å›¾è¡¨ç¼–è¾‘</button>
                        <button class="btn-toggle" onclick="toggleTrendline('${
                          tl.id
                        }')">
                            ${tl.enabled ? 'ç¦ç”¨' : 'å¯ç”¨'}
                        </button>
                        <button class="btn-edit" onclick="editTrendline('${
                          tl.id
                        }')">è¯¦ç»†ç¼–è¾‘</button>
                        <button class="btn-delete" onclick="deleteTrendline('${
                          tl.id
                        }')">åˆ é™¤</button>
                    </div>
                </div>
            `
          )
          .join('')
      }

      // ç»˜åˆ¶ç°æœ‰è¶‹åŠ¿çº¿
      function drawExistingTrendlines() {
        // æ¸…é™¤ç°æœ‰è¶‹åŠ¿çº¿
        trendlineSeries.forEach((series) => chart.removeSeries(series))
        trendlineSeries = []

        fetch(`/api/trendlines?symbol=${currentSymbol}`)
          .then((response) => response.json())
          .then((trendlines) => {
            console.log('è¶‹åŠ¿çº¿æ•°æ®:', trendlines)
            if (trendlines && trendlines.success && trendlines.data) {
              trendlines.data
                .filter((tl) => tl.enabled === true)
                .forEach((tl) => {
                  console.log('ç»˜åˆ¶è¶‹åŠ¿çº¿:', tl)
                  drawTrendlineOnChart(tl)
                })
            }
          })
          .catch((error) => {
            console.error('åŠ è½½è¶‹åŠ¿çº¿å¤±è´¥:', error)
          })
      }

      // åœ¨å›¾è¡¨ä¸Šç»˜åˆ¶è¶‹åŠ¿çº¿
      function drawTrendlineOnChart(trendline) {
        try {
          console.log('å¼€å§‹ç»˜åˆ¶è¶‹åŠ¿çº¿:', trendline)

          // ç¡®å®šé¢œè‰²ï¼šdirection=1ä¸ºå¤šå¤´ï¼ˆç»¿è‰²ï¼‰ï¼Œdirection=-1ä¸ºç©ºå¤´ï¼ˆçº¢è‰²ï¼‰
          const color = trendline.direction === 1 ? '#26a69a' : '#ef5350'

          const lineSeries = chart.addLineSeries({
            color: color,
            lineWidth: 2,
            priceLineVisible: false,
            lastValueVisible: false,
            // title: trendline.name,
          })

          // è·å–å½“å‰Kçº¿æ•°æ®
          const klineData = candlestickSeries.data()
          if (!klineData || klineData.length < 2) {
            console.warn('Kçº¿æ•°æ®ä¸è¶³ï¼Œæ— æ³•ç»˜åˆ¶è¶‹åŠ¿çº¿')
            return
          }

          // è½¬æ¢è¶‹åŠ¿çº¿æ—¶é—´ä¸ºæ—¶é—´æˆ³
          const startTime =
            new Date(trendline.startPoint.time).getTime() / 1000 + timeZonetimes
          const endTime =
            new Date(trendline.endPoint.time).getTime() / 1000 + timeZonetimes

          const startPrice = parseFloat(trendline.startPoint.price)
          const endPrice = parseFloat(trendline.endPoint.price)

          console.log('è¶‹åŠ¿çº¿æ•°æ®:', {
            startTime,
            endTime,
            startPrice,
            endPrice,
          })

          // è®¡ç®—è¶‹åŠ¿çº¿æ–œç‡ï¼ˆåŸºäºSignals.pyçš„é€»è¾‘ï¼‰
          const startIndex = klineData.findIndex((k) => k.time >= startTime)
          const endIndex = klineData.findIndex((k) => k.time >= endTime)

          if (startIndex === -1 || endIndex === -1) {
            console.warn('è¶‹åŠ¿çº¿æ—¶é—´è¶…å‡ºKçº¿æ•°æ®èŒƒå›´')
            return
          }

          // è®¡ç®—æ–œç‡
          const slope = (endPrice - startPrice) / (endIndex - startIndex)

          // ç”Ÿæˆè¶‹åŠ¿çº¿æ•°æ®ç‚¹ï¼ˆä»èµ·ç‚¹å¼€å§‹å»¶ä¼¸åˆ°å³ä¾§ï¼‰
          const trendlineData = []
          const firstKlineTime = klineData[0].time
          const lastKlineTime = klineData[klineData.length - 1].time

          // ä»è¶‹åŠ¿çº¿èµ·ç‚¹å¼€å§‹ï¼Œå»¶ä¼¸åˆ°Kçº¿æ•°æ®çš„æœ«å°¾
          const extendStartTime = Math.max(startTime, firstKlineTime)
          const extendEndTime = lastKlineTime

          const startIdx = klineData.findIndex((k) => k.time >= extendStartTime)
          if (startIdx === -1) return

          for (let i = startIdx; i < klineData.length; i++) {
            const currentTime = klineData[i].time
            const relativeIndex = i - startIndex
            const trendlineValue = startPrice + slope * relativeIndex

            trendlineData.push({
              time: currentTime,
              value: trendlineValue,
            })
          }

          console.log('è®¾ç½®è¶‹åŠ¿çº¿æ•°æ®ç‚¹æ•°:', trendlineData.length)
          lineSeries.setData(trendlineData)

          trendlineSeries.push(lineSeries)
          console.log('è¶‹åŠ¿çº¿ç»˜åˆ¶å®Œæˆ')
        } catch (error) {
          console.error('ç»˜åˆ¶è¶‹åŠ¿çº¿å¤±è´¥:', error)
        }
      }

      // åˆ‡æ¢è¶‹åŠ¿çº¿çŠ¶æ€
      function toggleTrendline(id) {
        // å…ˆè·å–å½“å‰è¶‹åŠ¿çº¿çŠ¶æ€
        fetch(`/api/trendlines/${id}`)
          .then((response) => response.json())
          .then((trendlineData) => {
            if (trendlineData && trendlineData.success && trendlineData.data) {
              const currentEnabled = trendlineData.data.enabled
              const newEnabled = !currentEnabled

              // æ›´æ–°çŠ¶æ€
              fetch(`/api/trendlines/${id}`, {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ enabled: newEnabled }),
              })
                .then((response) => response.json())
                .then((data) => {
                  if (data.error) {
                    showStatus('æ“ä½œå¤±è´¥: ' + data.error, 'error')
                  } else {
                    showStatus(
                      `è¶‹åŠ¿çº¿å·²${newEnabled ? 'å¯ç”¨' : 'ç¦ç”¨'}`,
                      'success'
                    )
                    loadTrendlines()
                    drawExistingTrendlines() // é‡æ–°ç»˜åˆ¶è¶‹åŠ¿çº¿
                  }
                })
            }
          })
          .catch((error) => {
            console.error('è·å–è¶‹åŠ¿çº¿çŠ¶æ€å¤±è´¥:', error)
            showStatus('æ“ä½œå¤±è´¥', 'error')
          })
      }

      // ç¼–è¾‘è¶‹åŠ¿çº¿
      function editTrendline(id) {
        // è·å–è¶‹åŠ¿çº¿è¯¦æƒ…
        fetch(`/api/trendlines/${id}`)
          .then((response) => response.json())
          .then((data) => {
            if (data.success && data.data) {
              const trendline = data.data
              showEditDialog(trendline)
            } else {
              showStatus('è·å–è¶‹åŠ¿çº¿ä¿¡æ¯å¤±è´¥', 'error')
            }
          })
          .catch((error) => {
            console.error('è·å–è¶‹åŠ¿çº¿ä¿¡æ¯å¤±è´¥:', error)
            showStatus('è·å–è¶‹åŠ¿çº¿ä¿¡æ¯å¤±è´¥', 'error')
          })
      }

      // æ˜¾ç¤ºç¼–è¾‘å¯¹è¯æ¡†
      function showEditDialog(trendline) {
        // åˆ›å»ºå¯¹è¯æ¡†HTML
        const dialogHtml = `
          <div id="editDialog" style="
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
          ">
            <div style="
              background: white;
              padding: 20px;
              border-radius: 8px;
              width: 400px;
              max-width: 90vw;
              box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            ">
              <h3 style="margin-top: 0; color: #333;">ç¼–è¾‘è¶‹åŠ¿çº¿</h3>
<div style="margin-bottom: 15px;display:none">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">åç§°:</label>
                <input type="text" id="editName" value="${
                  trendline.name
                }" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid #ddd;
                  border-radius: 4px;
                  box-sizing: border-box;
                ">
              </div>


              <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">æ–¹å‘:</label>
                <select id="editDirection" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid #ddd;
                  border-radius: 4px;
                  box-sizing: border-box;
                ">
                  <option value="1" ${
                    trendline.direction === 1 ? 'selected' : ''
                  }>åšå¤š ğŸ“ˆ</option>
                  <option value="-1" ${
                    trendline.direction === -1 ? 'selected' : ''
                  }>åšç©º ğŸ“‰</option>
                </select>
              </div>

              <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">èµ·ç‚¹æ—¶é—´:</label>
                <div style="display: flex; gap: 5px;">
                  <input type="datetime-local" id="editStartTime" value="${convertToDateTimeLocal(
                    trendline.startPoint.time
                  )}" style="
                    flex: 1;
                    padding: 8px;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    box-sizing: border-box;
                  ">
                  <button type="button" onclick="setStartTimeToNow()" style="
                    padding: 8px 12px;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    background: #f0f0f0;
                    cursor: pointer;
                    white-space: nowrap;
                  ">ç°åœ¨</button>
                </div>
              </div>

              <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">èµ·ç‚¹ä»·æ ¼:</label>
                <input type="number" id="editStartPrice" value="${parseFloat(
                  trendline.startPoint.price
                ).toFixed(2)}" step="0.01" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid #ddd;
                  border-radius: 4px;
                  box-sizing: border-box;
                ">
              </div>

              <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">ç»ˆç‚¹æ—¶é—´:</label>
                <div style="display: flex; gap: 5px;">
                  <input type="datetime-local" id="editEndTime" value="${convertToDateTimeLocal(
                    trendline.endPoint.time
                  )}" style="
                    flex: 1;
                    padding: 8px;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    box-sizing: border-box;
                  ">
                  <button type="button" onclick="setEndTimeToNow()" style="
                    padding: 8px 12px;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    background: #f0f0f0;
                    cursor: pointer;
                    white-space: nowrap;
                  ">ç°åœ¨</button>
                </div>
              </div>

              <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">ç»ˆç‚¹ä»·æ ¼:</label>
                <input type="number" id="editEndPrice" value="${parseFloat(
                  trendline.endPoint.price
                ).toFixed(2)}" step="0.01" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid #ddd;
                  border-radius: 4px;
                  box-sizing: border-box;
                ">
              </div>

              <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="closeEditDialog()" style="
                  padding: 8px 16px;
                  border: 1px solid #ddd;
                  border-radius: 4px;
                  background: #f5f5f5;
                  cursor: pointer;
                ">å–æ¶ˆ</button>
                <button onclick="saveTrendlineEdit('${trendline.id}')" style="
                  padding: 8px 16px;
                  border: none;
                  border-radius: 4px;
                  background: #4caf50;
                  color: white;
                  cursor: pointer;
                ">ä¿å­˜</button>
              </div>
            </div>
          </div>
        `

        // æ·»åŠ å¯¹è¯æ¡†åˆ°é¡µé¢
        document.body.insertAdjacentHTML('beforeend', dialogHtml)
      }

      // è½¬æ¢æ—¶é—´æ ¼å¼ä¸ºdatetime-localæ ¼å¼
      function convertToDateTimeLocal(timeString) {
        try {
          const date = new Date(timeString)
          const year = date.getFullYear()
          const month = String(date.getMonth() + 1).padStart(2, '0')
          const day = String(date.getDate()).padStart(2, '0')
          const hours = String(date.getHours()).padStart(2, '0')
          const minutes = String(date.getMinutes()).padStart(2, '0')
          return `${year}-${month}-${day}T${hours}:${minutes}`
        } catch (e) {
          console.error('æ—¶é—´æ ¼å¼è½¬æ¢å¤±è´¥:', e)
          return ''
        }
      }

      // è®¾ç½®èµ·ç‚¹æ—¶é—´ä¸ºå½“å‰æ—¶é—´
      function setStartTimeToNow() {
        const now = new Date()
        const year = now.getFullYear()
        const month = String(now.getMonth() + 1).padStart(2, '0')
        const day = String(now.getDate()).padStart(2, '0')
        const hours = String(now.getHours()).padStart(2, '0')
        const minutes = String(now.getMinutes()).padStart(2, '0')
        const dateTimeLocal = `${year}-${month}-${day}T${hours}:${minutes}`
        document.getElementById('editStartTime').value = dateTimeLocal
      }

      // è®¾ç½®ç»ˆç‚¹æ—¶é—´ä¸ºå½“å‰æ—¶é—´
      function setEndTimeToNow() {
        const now = new Date()
        const year = now.getFullYear()
        const month = String(now.getMonth() + 1).padStart(2, '0')
        const day = String(now.getDate()).padStart(2, '0')
        const hours = String(now.getHours()).padStart(2, '0')
        const minutes = String(now.getMinutes()).padStart(2, '0')
        const dateTimeLocal = `${year}-${month}-${day}T${hours}:${minutes}`
        document.getElementById('editEndTime').value = dateTimeLocal
      }

      // å…³é—­ç¼–è¾‘å¯¹è¯æ¡†
      function closeEditDialog() {
        const dialog = document.getElementById('editDialog')
        if (dialog) {
          dialog.remove()
        }
      }

      // æ·»åŠ å¯¹è¯æ¡†äº‹ä»¶ç›‘å¬ï¼ˆç‚¹å‡»å¤–éƒ¨å…³é—­ï¼‰
      document.addEventListener('click', function (event) {
        const dialog = document.getElementById('editDialog')
        if (dialog && event.target === dialog) {
          closeEditDialog()
        }
      })

      // æ·»åŠ ESCé”®å…³é—­å¯¹è¯æ¡†
      document.addEventListener('keydown', function (event) {
        if (event.key === 'Escape') {
          const dialog = document.getElementById('editDialog')
          if (dialog) {
            closeEditDialog()
          }
        }
      })

      // ä¿å­˜è¶‹åŠ¿çº¿ç¼–è¾‘
      function saveTrendlineEdit(id) {
        const name = document.getElementById('editName').value.trim()
        const direction = parseInt(
          document.getElementById('editDirection').value
        )
        const startTime = document.getElementById('editStartTime').value
        const startPrice = parseFloat(
          document.getElementById('editStartPrice').value
        )
        const endTime = document.getElementById('editEndTime').value
        const endPrice = parseFloat(
          document.getElementById('editEndPrice').value
        )

        // éªŒè¯è¾“å…¥
        if (!name) {
          showStatus('è¶‹åŠ¿çº¿åç§°ä¸èƒ½ä¸ºç©º', 'error')
          return
        }

        if (!startTime || !endTime) {
          showStatus('è¯·é€‰æ‹©èµ·ç‚¹å’Œç»ˆç‚¹æ—¶é—´', 'error')
          return
        }

        if (isNaN(startPrice) || isNaN(endPrice)) {
          showStatus('è¯·è¾“å…¥æœ‰æ•ˆçš„ä»·æ ¼', 'error')
          return
        }

        if (startPrice <= 0 || endPrice <= 0) {
          showStatus('ä»·æ ¼å¿…é¡»å¤§äº0', 'error')
          return
        }

        // è½¬æ¢æ—¶é—´æ ¼å¼
        const startTimeString = convertDateTimeLocalToString(startTime)
        const endTimeString = convertDateTimeLocalToString(endTime)

        // éªŒè¯æ—¶é—´é¡ºåº
        const startDate = new Date(startTime)
        const endDate = new Date(endTime)
        if (startDate >= endDate) {
          showStatus('ç»ˆç‚¹æ—¶é—´å¿…é¡»æ™šäºèµ·ç‚¹æ—¶é—´', 'error')
          return
        }

        // æ„å»ºæ›´æ–°æ•°æ®
        const updateData = {
          name: name,
          direction: direction,
          startPoint: {
            time: startTimeString,
            price: startPrice.toFixed(2),
          },
          endPoint: {
            time: endTimeString,
            price: endPrice.toFixed(2),
          },
        }

        console.log('æ›´æ–°è¶‹åŠ¿çº¿æ•°æ®:', updateData)

        // å‘é€æ›´æ–°è¯·æ±‚
        fetch(`/api/trendlines/${id}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(updateData),
        })
          .then((response) => response.json())
          .then((result) => {
            if (result.success) {
              showStatus('è¶‹åŠ¿çº¿æ›´æ–°æˆåŠŸ', 'success')
              closeEditDialog()
              loadTrendlines()
              drawExistingTrendlines()
            } else {
              showStatus('æ›´æ–°å¤±è´¥: ' + (result.message || 'æœªçŸ¥é”™è¯¯'), 'error')
            }
          })
          .catch((error) => {
            console.error('æ›´æ–°è¶‹åŠ¿çº¿å¤±è´¥:', error)
            showStatus('æ›´æ–°å¤±è´¥: ' + error.message, 'error')
          })
      }

      // è½¬æ¢datetime-localæ ¼å¼ä¸ºå­—ç¬¦ä¸²
      function convertDateTimeLocalToString(dateTimeLocal) {
        try {
          const date = new Date(dateTimeLocal)
          const year = date.getFullYear()
          const month = String(date.getMonth() + 1).padStart(2, '0')
          const day = String(date.getDate()).padStart(2, '0')
          const hour = String(date.getHours()).padStart(2, '0')
          const minute = String(date.getMinutes()).padStart(2, '0')
          const second = String(date.getSeconds()).padStart(2, '0')
          return `${year}-${month}-${day} ${hour}:${minute}:${second}`
        } catch (e) {
          console.error('æ—¶é—´æ ¼å¼è½¬æ¢å¤±è´¥:', e)
          return ''
        }
      }

      // ä»å›¾è¡¨å¼€å§‹ç¼–è¾‘è¶‹åŠ¿çº¿
      function startEditTrendlineFromChart(id) {
        // è·å–è¶‹åŠ¿çº¿ä¿¡æ¯
        fetch(`/api/trendlines/${id}`)
          .then((response) => response.json())
          .then((data) => {
            if (data.success && data.data) {
              const trendline = data.data
              editingTrendlineId = id
              editingOriginalData = trendline

              // è¿›å…¥ç¼–è¾‘æ¨¡å¼
              isEditMode = true
              selectedPoints = []

              // æ›´æ–°UIæ˜¾ç¤º
              document.getElementById('drawTrendlineBtn').style.display = 'none'
              document.getElementById('clearSelectionBtn').style.display =
                'inline-block'
              document.getElementById('clearSelectionBtn').textContent =
                'å–æ¶ˆç¼–è¾‘'

              showStatus(
                `è¯·ç‚¹å‡»å›¾è¡¨é€‰æ‹©æ–°çš„è¶‹åŠ¿çº¿èµ·ç‚¹ï¼Œæˆ–ç‚¹å‡»å–æ¶ˆä¿ç•™åŸå€¼`,
                'success'
              )
            } else {
              showStatus('è·å–è¶‹åŠ¿çº¿ä¿¡æ¯å¤±è´¥', 'error')
            }
          })
          .catch((error) => {
            console.error('è·å–è¶‹åŠ¿çº¿ä¿¡æ¯å¤±è´¥:', error)
            showStatus('è·å–è¶‹åŠ¿çº¿ä¿¡æ¯å¤±è´¥', 'error')
          })
      }

      // å…¨å±€å˜é‡å­˜å‚¨å½“å‰é¼ æ ‡ä½ç½®çš„ä»·æ ¼
      let currentHoverPrice = null

      // å¤„ç†åå­—çº¿ç§»åŠ¨äº‹ä»¶ï¼Œç”¨äºè·å–å‡†ç¡®çš„ä»·æ ¼
      function handleCrosshairMove(param) {
        if (!param.time || !param.point || !candlestickSeries) return

        // å°è¯•ä»seriesPricesè·å–ä»·æ ¼
        if (
          param.seriesPrices &&
          param.seriesPrices.has &&
          param.seriesPrices.has(candlestickSeries)
        ) {
          currentHoverPrice = param.seriesPrices.get(candlestickSeries)
        } else if (param.seriesData && param.seriesData.candlestick) {
          // å°è¯•ä»seriesDataè·å–ä»·æ ¼
          const candleData = param.seriesData.candlestick
          currentHoverPrice =
            candleData.close ||
            candleData.open ||
            (candleData.high + candleData.low) / 2
        } else {
          // ä½¿ç”¨é¼ æ ‡Yåæ ‡å¯¹åº”çš„ä»·æ ¼ï¼ˆè¿‘ä¼¼å€¼ï¼‰
          currentHoverPrice = null
        }
      }

      // å¤„ç†å›¾è¡¨ç‚¹å‡»äº‹ä»¶ï¼ˆæ”¯æŒç»˜åˆ¶å’Œç¼–è¾‘æ¨¡å¼ï¼‰
      function handleChartClick(param) {
        // å§‹ç»ˆæ˜¾ç¤ºåæ ‡ä¿¡æ¯ï¼ˆdemoåŠŸèƒ½ï¼‰
        showClickCoordinates(param)

        if (!isDrawingMode && !isEditMode) return

        // ç¡®ä¿å›¾è¡¨å’Œç³»åˆ—å·²åˆå§‹åŒ–
        if (!chart || !candlestickSeries) {
          console.warn('å›¾è¡¨æˆ–ç³»åˆ—æœªåˆå§‹åŒ–')
          return
        }

        if (!param.time || !param.point) return

        // è·å–ç‚¹å‡»ä½ç½®çš„å…·ä½“ä»·æ ¼
        let clickPrice = null
        let priceData = null

        // å¦‚æœç‚¹å‡»åˆ°å…·ä½“çš„Kçº¿æ•°æ®ç‚¹ï¼Œä½¿ç”¨ç‚¹å‡»ä½ç½®çš„ä»·æ ¼
        if (param.seriesData && param.seriesData.size > 0) {
          priceData = param.seriesData.get(candlestickSeries)
        }

        // ä½¿ç”¨coordinateToPriceè·å–ç‚¹å‡»ä½ç½®çš„ç²¾ç¡®ä»·æ ¼
        if (param.point && param.point.y) {
          clickPrice = candlestickSeries.coordinateToPrice(param.point.y)
        }

        // å¦‚æœä»ç„¶æ²¡æœ‰è·å–åˆ°ä»·æ ¼ï¼Œæ˜¾ç¤ºé”™è¯¯
        if (!clickPrice || isNaN(clickPrice)) {
          console.warn('æ— æ³•è·å–ä»·æ ¼æ•°æ®')
          showStatus('æ— æ³•è·å–ä»·æ ¼æ•°æ®ï¼Œè¯·é‡è¯•', 'error')
          return
        }

        // ä¿å­˜ç‚¹å‡»ä»·æ ¼ä¿¡æ¯
        let clickPriceInfo = {}

        // è·å–è¯¦ç»†çš„ä»·æ ¼ä¿¡æ¯
        if (priceData) {
          // å¦‚æœç‚¹å‡»åˆ°Kçº¿ï¼Œæ˜¾ç¤ºKçº¿ä¿¡æ¯å’Œç‚¹å‡»ä»·æ ¼
          clickPriceInfo = {
            // clickPrice: clickPrice,
            // open: priceData.open,
            // high: priceData.high,
            // low: priceData.low,
            // close: priceData.close,
            // description: `ç‚¹å‡»ä»·æ ¼: ${clickPrice.toFixed(2)} | Kçº¿ä¿¡æ¯ - å¼€: ${
            // priceData.open
            // } | é«˜: ${priceData.high} | ä½: ${priceData.low} | æ”¶: ${
            // priceData.close
            // }`,
          }
        } else {
          // å¦‚æœæ²¡æœ‰ç‚¹å‡»åˆ°Kçº¿ï¼Œåªæ˜¾ç¤ºç‚¹å‡»ä½ç½®çš„ä»·æ ¼
          clickPriceInfo = {
            clickPrice: clickPrice,
            description: `ç‚¹å‡»ä½ç½®ä»·æ ¼: ${clickPrice.toFixed(2)}`,
          }
        }

        selectedPoints.push({
          time: param.time - 8 * 3600,
          price: clickPrice,
          x: param.point.x,
          y: param.point.y,
          priceInfo: clickPriceInfo,
        })

        // å¤„ç†ç‚¹å‡»åçš„é€»è¾‘
        if (isEditMode) {
          if (selectedPoints.length === 1) {
            showStatus('å·²é€‰æ‹©æ–°èµ·ç‚¹ï¼Œè¯·ç‚¹å‡»ç»ˆç‚¹', 'success')
          } else if (selectedPoints.length === 2) {
            updateTrendlineFromChart()
          }
        } else {
          if (selectedPoints.length === 1) {
            showStatus('å·²é€‰æ‹©èµ·ç‚¹ï¼Œè¯·ç‚¹å‡»ç»ˆç‚¹', 'success')
          } else if (selectedPoints.length === 2) {
            createTrendline()
          }
        }
      }

      // æ˜¾ç¤ºç‚¹å‡»åæ ‡ä¿¡æ¯ï¼ˆDemoåŠŸèƒ½ï¼‰- å®Œå…¨æŒ‰ç…§tt.htmlå®ç°
      function showClickCoordinates(param) {
        if (!param || !param.point || !chart) return

        const pixelX = param.point.x
        const pixelY = param.point.y

        // æŒ‰ç…§tt.htmlçš„é€»è¾‘å¤„ç†
        if (param.point && param.time) {
          // æ˜¾ç¤ºæ—¶é—´ - å®Œå…¨æŒ‰ç…§tt.htmlçš„æ–¹å¼
          const date = new Date((param.time - 8 * 3600) * 1000)
          const timeStr =
            date.toLocaleDateString('zh-CN') +
            ' ' +
            date.toLocaleTimeString('zh-CN')

          // æ˜¾ç¤ºYè½´å¯¹åº”çš„ä»·æ ¼ - æŒ‰ç…§tt.htmlçš„æ–¹å¼
          const time = chart.timeScale().coordinateToTime(param.point.x)
          const price = candlestickSeries.coordinateToPrice(param.point.y)

          let priceInfo = ''
          console.log('ç‚¹å‡»ä»·æ ¼', price, 'ç‚¹å‡»æ—¶é—´', time, date, timeStr)

          // å¦‚æœç‚¹å‡»åˆ°å…·ä½“çš„Kçº¿æ•°æ®ç‚¹ï¼Œæ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
          if (param.seriesData && param.seriesData.size > 0) {
            const priceData = param.seriesData.get(candlestickSeries)
            // if (priceData) {
            // priceInfo = `ç‚¹å‡»ä»·æ ¼: ${price.toFixed(2)} | å¼€: ${
            // priceData.open
            // } | é«˜: ${priceData.high} | ä½: ${priceData.low} | æ”¶: ${
            // priceData.close
            // }`
            // }
          } else {
            // å¦‚æœæ²¡æœ‰ç‚¹å‡»åˆ°Kçº¿ï¼Œåªæ˜¾ç¤ºç‚¹å‡»ä½ç½®çš„ä»·æ ¼
            priceInfo = `ç‚¹å‡»ä½ç½®ä»·æ ¼: ${price.toFixed(2)}`
          }

          // æ›´æ–°é¡µé¢ä¸Šçš„åæ ‡æ˜¾ç¤º
          updateCoordinateDisplay(
            pixelX,
            pixelY,
            timeStr,
            priceInfo,
            param.time,
            price
          )
        } else if (!param.point) {
          updateCoordinateDisplay(pixelX, pixelY, 'è¯·ç‚¹å‡»å›¾è¡¨', '-', null, null)
        }
      }

      // æ›´æ–°é¡µé¢åæ ‡æ˜¾ç¤º - å®Œå…¨æŒ‰ç…§tt.htmlé£æ ¼
      function updateCoordinateDisplay(
        pixelX,
        pixelY,
        timeStr,
        priceInfo,
        axisTime,
        axisPrice
      ) {
        let coordDiv = document.getElementById('coordinate-display')
        if (!coordDiv) {
          // åˆ›å»ºåæ ‡æ˜¾ç¤ºåŒºåŸŸ
          coordDiv = document.createElement('div')
          coordDiv.id = 'coordinate-display'
          coordDiv.style.cssText = `
            display: none;
            position: fixed;
            top: 10px;
            right: 10px;
            background: #2a2e39;
            color: #fff;
            padding: 15px;
            border-radius: 8px;
            font-family: Arial, sans-serif;
            font-size: 16px;
            z-index: 1000;
            min-width: 320px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.1);
          `
          document.body.appendChild(coordDiv)
        }

        coordDiv.innerHTML = `
          <div style="margin-bottom: 15px;">
            <span style="color: #888; display: inline-block; width: 80px;">åƒç´ åæ ‡:</span>
            <span style="color: #2962ff; font-weight: bold;">(${pixelX.toFixed(
              1
            )}, ${pixelY.toFixed(1)})</span>
          </div>
          <div style="margin-bottom: 15px;">
            <span style="color: #888; display: inline-block; width: 80px;">æ—¶é—´:</span>
            <span style="color: #2962ff; font-weight: bold;">${timeStr}</span>
          </div>
          <div>
            <span style="color: #888; display: inline-block; width: 80px;">ä»·æ ¼ä¿¡æ¯:</span>
            <span style="color: #2962ff; font-weight: bold; word-break: break-all;">${priceInfo}</span>
          </div>
        `
      }

      // ä»å›¾è¡¨é€‰æ‹©æ›´æ–°è¶‹åŠ¿çº¿
      function updateTrendlineFromChart() {
        if (selectedPoints.length !== 2 || !editingTrendlineId) return

        const startPoint = selectedPoints[0]
        const endPoint = selectedPoints[1]

        // è®¡ç®—æ–°çš„æ–¹å‘ï¼ˆåŸºäºä»·æ ¼å˜åŒ–ï¼‰
        const newDirection = endPoint.price > startPoint.price ? 1 : -1

        // æ„å»ºæ›´æ–°æ•°æ®
        const updateData = {
          name: editingOriginalData.name,
          direction: newDirection,
          startPoint: {
            time: convertTimeToString(startPoint.time),
            price: startPoint.price.toFixed(2),
            priceInfo: startPoint.priceInfo
              ? startPoint.priceInfo.description
              : null,
            candleData: startPoint.priceInfo
              ? {
                  open: startPoint.priceInfo.open,
                  high: startPoint.priceInfo.high,
                  low: startPoint.priceInfo.low,
                  close: startPoint.priceInfo.close,
                }
              : null,
          },
          endPoint: {
            time: convertTimeToString(endPoint.time),
            price: endPoint.price.toFixed(2),
            priceInfo: endPoint.priceInfo
              ? endPoint.priceInfo.description
              : null,
            candleData: endPoint.priceInfo
              ? {
                  open: endPoint.priceInfo.open,
                  high: endPoint.priceInfo.high,
                  low: endPoint.priceInfo.low,
                  close: endPoint.priceInfo.close,
                }
              : null,
          },
        }

        console.log('ä»å›¾è¡¨æ›´æ–°è¶‹åŠ¿çº¿:', updateData)

        // å‘é€æ›´æ–°è¯·æ±‚
        fetch(`/api/trendlines/${editingTrendlineId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(updateData),
        })
          .then((response) => response.json())
          .then((result) => {
            if (result.success) {
              showStatus('è¶‹åŠ¿çº¿ä»å›¾è¡¨æ›´æ–°æˆåŠŸ', 'success')
              exitEditMode()
              loadTrendlines()
              drawExistingTrendlines()
            } else {
              showStatus('æ›´æ–°å¤±è´¥: ' + (result.message || 'æœªçŸ¥é”™è¯¯'), 'error')
            }
          })
          .catch((error) => {
            console.error('æ›´æ–°è¶‹åŠ¿çº¿å¤±è´¥:', error)
            showStatus('æ›´æ–°å¤±è´¥: ' + error.message, 'error')
          })
      }

      // é€€å‡ºç¼–è¾‘æ¨¡å¼
      function exitEditMode() {
        isEditMode = false
        editingTrendlineId = null
        editingOriginalData = null
        clearSelection()

        // æ¢å¤æŒ‰é’®çŠ¶æ€
        document.getElementById('drawTrendlineBtn').style.display =
          'inline-block'
        document.getElementById('clearSelectionBtn').textContent = 'å–æ¶ˆé€‰æ‹©'
      }

      // æ›´æ–°æ¸…é™¤é€‰æ‹©åŠŸèƒ½
      function clearSelection() {
        selectedPoints = []
        isDrawingMode = false

        if (isEditMode) {
          exitEditMode()
        } else {
          document.getElementById('drawTrendlineBtn').style.display =
            'inline-block'
          document.getElementById('clearSelectionBtn').style.display = 'none'
        }
      }

      // æ£€æŸ¥è¶‹åŠ¿çº¿çªç ´
      function checkTrendlineBreakout(id) {
        showStatus('æ­£åœ¨æ£€æŸ¥çªç ´ä¿¡å·...', 'success')

        fetch(`/api/trendlines/${id}/check`, {
          method: 'POST',
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              const result = data.data
              console.log('çªç ´æ£€æµ‹ç»“æœ:', result)

              if (result.breakout_signal === 1) {
                showStatus('ğŸš¨ æ£€æµ‹åˆ°å‘ä¸Šçªç ´ä¿¡å·ï¼', 'success')
              } else if (result.breakout_signal === -1) {
                showStatus('ğŸš¨ æ£€æµ‹åˆ°å‘ä¸‹è·Œç ´ä¿¡å·ï¼', 'error')
              } else {
                showStatus('æš‚æ— çªç ´ä¿¡å·', 'success')
              }

              // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
              if (result.current_price && result.trendline_value) {
                console.log(
                  `å½“å‰ä»·æ ¼: ${result.current_price}, è¶‹åŠ¿çº¿å€¼: ${result.trendline_value}`
                )
              }
            } else {
              showStatus('æ£€æŸ¥å¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'), 'error')
            }
          })
          .catch((error) => {
            console.error('æ£€æŸ¥çªç ´å¤±è´¥:', error)
            showStatus('æ£€æŸ¥çªç ´å¤±è´¥: ' + error.message, 'error')
          })
      }

      // åˆ é™¤è¶‹åŠ¿çº¿
      function deleteTrendline(id) {
        if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡è¶‹åŠ¿çº¿å—ï¼Ÿ')) return

        fetch(`/api/trendlines/${id}`, {
          method: 'DELETE',
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              showStatus('åˆ é™¤æˆåŠŸ', 'success')
              loadTrendlines()
              drawExistingTrendlines()
            } else {
              showStatus('åˆ é™¤å¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'), 'error')
            }
          })
          .catch((error) => {
            console.error('åˆ é™¤è¶‹åŠ¿çº¿å¤±è´¥:', error)
            showStatus('åˆ é™¤å¤±è´¥: ' + error.message, 'error')
          })
      }

      // æ¸…é™¤é€‰æ‹©
      function clearSelection() {
        selectedPoints = []
        isDrawingMode = false
        document.getElementById('drawTrendlineBtn').style.display =
          'inline-block'
        document.getElementById('clearSelectionBtn').style.display = 'none'
      }

      // æ˜¾ç¤ºçŠ¶æ€ä¿¡æ¯
      function showStatus(message, type) {
        // const status = document.getElementById('status')
        // status.textContent = message
        // status.className = 'status ' + type
        // status.style.display = 'block'
        // setTimeout(() => {
        // status.style.display = 'none'
        // }, 3000)
      }

      // æ›´æ–°æ•°æ®ä¿¡æ¯æ˜¾ç¤º
      function updateDataInfo(data) {
        const dataInfo = document.getElementById('dataInfo')
        if (data && data.length > 0) {
          const firstTime = new Date(data[0].time * 1000)
          const lastTime = new Date(data[data.length - 1].time * 1000)
          dataInfo.textContent = `${
            data.length
          }æ¡Kçº¿ | ${firstTime.toLocaleDateString()} ${firstTime.toLocaleTimeString()} - ${lastTime.toLocaleDateString()} ${lastTime.toLocaleTimeString()}`
        } else {
          dataInfo.textContent = 'æš‚æ— æ•°æ®'
        }
      }

      // äº‹ä»¶ç›‘å¬
      document
        .getElementById('symbolSelect')
        .addEventListener('change', (e) => {
          currentSymbol = e.target.value

          // æ¸…é™¤é€‰æ‹©çŠ¶æ€
          clearSelection()

          // åŠ è½½æ–°å¸ç§çš„æ•°æ®
          loadKlineData().finally(() => {
            // é‡æ–°åŠ è½½è¯¥å¸ç§çš„è¶‹åŠ¿çº¿
            loadTrendlines()
          })

        })

      document
        .getElementById('refreshBtn')
        .addEventListener('click', loadKlineData)

      document
        .getElementById('drawTrendlineBtn')
        .addEventListener('click', () => {
          isDrawingMode = true
          selectedPoints = []
          document.getElementById('drawTrendlineBtn').style.display = 'none'
          document.getElementById('clearSelectionBtn').style.display =
            'inline-block'
          showStatus('è¯·ç‚¹å‡»å›¾è¡¨é€‰æ‹©è¶‹åŠ¿çº¿èµ·ç‚¹', 'success')
        })

      document
        .getElementById('clearSelectionBtn')
        .addEventListener('click', clearSelection)

      // åˆå§‹åŒ–
      window.addEventListener('load', () => {
        showLoading()
        initChart()
        loadTrendlines().finally(() => {
          loadKlineData()
        })
      })

      // å“åº”å¼è°ƒæ•´
      window.addEventListener('resize', () => {
        chart.applyOptions({
          width: document.getElementById('chart').clientWidth,
        })
      })
    </script>
  </body>
</html>
